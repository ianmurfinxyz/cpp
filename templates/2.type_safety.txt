TYPE SAFE
---------

This file contains a discussion of template type safety. It is a set of notes compiled from
reading The C++ Programming Language 4th edition by Bjarne Stroustrup. The point of this file
is to elaborate on the discussion in the book, to explain to myself with the goal of furthering
understanding.

HOW ARE TEMPLATES TYPE SAFE?
----------------------------

on p666 Bjarne states,

"The composition offered by templates is type-safe (no object can be implicitly used in a way
which disagrees with its definition), ..."

on p672 he states,

"Type checking is done on the code generated by template instantiation (exactly as if the
programmer had expanded the templates by hand)."

Thus templates are type safe in the sense that all types used within a template can only be
used in a manner which agrees with its definition because eventually that template will become
concrete code. Thus normal type checking will be performed on the concrete code.

However Bjarne points out that this system of type safety has its downsides.

Since the template system is duck typed, no type checking is performed on the types within a
template until that template is instantiated and the type checking is performed on the 
generated code. This means that type checking is performed late. 

Bjarne states that the problems with this late type checking are that the code generated by the 
template "may contain much that the user of a template has never heard of (such as names of 
details of a template implementation)", thus these names will be output in the compilation 
errors, making for hard to understand and complicated errors. This I know from code I have 
written that produced errors in std templates, the error messages are always very long, 
complicated, and contain references to symbols which are implementation details. 

For example, the following code,

struct T {
  int i, ii;
};
int main(){
  T t;
  std::cout << t;
}

generates 250 lines of compilation error output (GCC) because the ostream doesn't know how to
output an instance of type T. Further the error messages contain references to std::basic_ostream
which is an implementation detail of cout (among other implementation detail symbols).

THE ABSENCE OF CONCEPTS
-----------------------

Bjarne points out that the reason type checking can only be performed late (on the generated
code) and not the templates themselves is because (as of C++11) the templates are purely duck
typed and there is no way to specify requirements on the arguments of the templates.

If for example you could specify that a template, which takes say a single argument, can only
accept arguments which are default constructable, then the compiler could check that all
specialisations of a template are done so with arguments which are default constructable, prior
to actually generating the code. This would allow the compiler to output a message like, type
'Thing' is not default constructable; required by template X. Instead the compiler generates
the code, then does type checking on the generated code and produces a zillion errors because
the code doesn't work. All the errors of which have nothing to do with the template but rather
to do with the generated code.

This is what the C++20 (and C++17?) feature of concepts introduces; a way to specify (at least
partially) the requirements on template arguments so type errors can be caught earlier.

Bjarne also points out that without concepts some errors are only caught at link time, and are
thus not even caught by the compiler.


